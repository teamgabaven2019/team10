;modjewel.define("weinre/client/ConnectorList", function(require, exports, module) { // Generated by CoffeeScript 1.3.3
var ConnectorList, dt;

dt = require('./DOMTemplates');

module.exports = ConnectorList = (function() {

  function ConnectorList(title) {
    this.connectors = {};
    this.noneItem = dt.OPTION("Waiting for Monaca Debugger connection...");
    this.noneItem.addStyleClass("weinre-connector-item");
    this.ulConnectors = dt.SELECT(this.noneItem);
    this.ulConnectors.disabled = true;
    this.div = dt.DIV(this.ulConnectors);
  }

  ConnectorList.prototype.getElement = function() {
    return this.div;
  };

  ConnectorList.prototype.refresh = function(device_id) {
    var channel, element, option, _results;
    _results = [];
    for (channel in this.connectors) {
      if (!this.connectors.hasOwnProperty(channel)) {
        continue;
      }
      option = this.getListItem(this.connectors[channel]);
      element = this.getConnectorElement(channel);
      if (!element) {
        continue;
      }
      _results.push(element.innerText = option.innerText);
    }
    return _results;
  };

  ConnectorList.prototype.add = function(connector) {
    var i, insertionPoint, o, option, _i, _len, _ref;
    this.connectors[connector.channel] = connector;
    option = this.getListItem(connector);
    this.noneItem.style.display = "none";
    this.ulConnectors.disabled = false;
    if (this.ulConnectors.options.length > 0) {
      i = 0;
      _ref = this.ulConnectors.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        if (o && o.value !== void 0 && o.value === connector.channel) {
          this.ulConnectors.remove(i);
        }
        i++;
      }
    }
    insertionPoint = this.getConnectorInsertionPoint(connector);
    if (!insertionPoint) {
      return this.ulConnectors.appendChild(option);
    } else {
      return this.ulConnectors.insertBefore(option, insertionPoint);
    }
  };

  ConnectorList.prototype.get = function(channel) {
    return this.connectors[channel];
  };

  ConnectorList.prototype.getNewestConnectorChannel = function(ignoring) {
    var connectorChannel, newest;
    newest = 0;
    for (connectorChannel in this.connectors) {
      if (connectorChannel === ignoring) {
        continue;
      }
      if (connectorChannel > newest) {
        newest = connectorChannel;
      }
    }
    if (newest === 0) {
      return null;
    }
    return newest;
  };

  ConnectorList.prototype.getConnectorInsertionPoint = function(connector) {
    var childNode, i, _i, _len, _ref;
    i = 0;
    _ref = this.ulConnectors.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      childNode = _ref[_i];
      if (null === childNode.connectorChannel) {
        continue;
      }
      if (childNode.connectorChannel < connector.channel) {
        return childNode;
      }
    }
    return null;
  };

  ConnectorList.prototype.remove = function(channel, fast) {
    var connector, element, ev, i, self, _i, _len, _ref;
    self = this;
    element = this.getConnectorElement(channel);
    if (!element) {
      return;
    }
    connector = this.connectors[channel];
    if (connector) {
      connector.closed = true;
    }
    delete this.connectors[channel];
    _ref = this.ulConnectors.options;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      if (typeof i !== "undefined" && i.value === channel) {
        this.ulConnectors.removeChild(i);
      }
    }
    if (this.getConnectors().length === 0) {
      this.noneItem.style.display = "list-item";
      this.ulConnectors.disabled = true;
    } else {
      this.setCurrent(this.getConnectors()[this.getConnectors().length - 1].channel);
    }
    ev = document.createEvent("HTMLEvents");
    ev.initEvent("change", true, false);
    return this.ulConnectors.dispatchEvent(ev);
  };

  ConnectorList.prototype.removeAll = function() {
    var connector, _i, _len, _ref, _results;
    _ref = this.getConnectors();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connector = _ref[_i];
      _results.push(this.remove(connector.channel, true));
    }
    return _results;
  };

  ConnectorList.prototype.getConnectors = function() {
    var channel, result;
    result = [];
    for (channel in this.connectors) {
      if (!this.connectors.hasOwnProperty(channel)) {
        continue;
      }
      result.push(this.connectors[channel]);
    }
    return result;
  };

  ConnectorList.prototype.getConnectorElement = function(channel) {
    var connector;
    connector = this.connectors[channel];
    if (!connector) {
      return null;
    }
    return connector.element;
  };

  ConnectorList.prototype.setCurrent = function(channel) {
    var connector, _i, _len, _ref;
    _ref = this.getConnectors();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connector = _ref[_i];
      connector.element.removeStyleClass("current");
    }
    return this.ulConnectors.value = channel;
  };

  ConnectorList.prototype.setState = function(channel, state) {
    var element;
    if (typeof channel === "string") {
      element = this.getConnectorElement(channel);
    } else {
      element = channel;
    }
    if (!element) {
      return;
    }
    element.removeStyleClass("error");
    element.removeStyleClass("closed");
    element.removeStyleClass("connected");
    element.removeStyleClass("not-connected");
    element.addStyleClass(state);
    if (state === "connected") {
      return this.ulConnectors.value = channel;
    }
  };

  return ConnectorList;

})();

require("../common/MethodNamer").setNamesForClass(module.exports);

});
